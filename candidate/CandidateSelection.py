import os
import sys
import csv
import tqdm
import random
import difflib
from util.io_util import *
from util.github_util import github_tokens, get_file_content, get_file_list
from util.similarity_util import *

class CandidateSelection:

    def __init__(self, project_root_path: str, module_root_path: str, cve_data_all: dict, repo_file_list: dict):
        self.project_root_path = project_root_path
        self.module_root_path = module_root_path
        self.cve_data_all = cve_data_all
        self.repo_file_list = repo_file_list

        # self.filter_file_pattern = [
        #     'changelog', 'news', 'changes', 'changelog', 'readme', 'makefile', 'license', 'authors', 'todo', 'TODO', 'copying', 'relnotes', 'thanks', 'notice','whatsnew', 'notes', 'release_notes', 'note', 'testlist', 'testsuite', 'test', '.gitignore', '.xlsx', '.xls', '.md', '.txt', '.doc', '.docx', '.pdf', '.rst', '.changes', '.rdoc', '.mdown', '.command', '.out', '.err', '.stderr', '.stdout', '.test', '.jpg', '.jpeg', '.png', '.svg', '.mp4', '.gif', '.exr', '.csv', '.rdf', '.ico', '.ttf', '.otf', '.woff', '.woff2', '.mock', '.stub', '.fake', '.ppt', '.pptx', '.key', '.bak', '.zip', '.gz', '.rar', '.bmp', '.yaml', '.yml', '.json', '.xml', '.ini', '.cfg', '.tar.gz', '.tgz', '.css', '.cygport', 'logo.', 'ui.js', 
        # ]

        # self.filter_list_suffix = [
        #     '.lib'
        # ]

        os.makedirs(self.module_root_path, exist_ok = True)

        self.cve_list_dir = f'{self.module_root_path}/cve_list'
        os.makedirs(self.cve_list_dir, exist_ok = True)


    def start(self):
        # self.filter_cve_list('212') # 212代表必须要有File，Module和Function有没有都行

        res = self.select_by_file_component(100)
        self.check_accuracy(res, 1)
        self.check_accuracy(res, 2)
        self.check_accuracy(res, 3)
        self.check_accuracy(res, 4)
        self.check_accuracy(res, 5)
        self.check_accuracy(res, 10)
        self.check_accuracy(res, 50)
        self.check_accuracy(res, 100)


    def filter_cve_list(self, mode: str):
        file_path = f'{self.cve_list_dir}/cve_list_{mode}'
        if os.path.exists(file_path):
            return load_pickle(f'{file_path}.pkl')
        
        cve_list = []
        type_list = ['Module', 'File', 'Function']
        for cve, v in self.cve_data_all.items():
            components = v.get('components')
            if components and v.get('collected_commit'):
                flag = True
                for index, mask in enumerate(mode):
                    if mask == '0':
                        if components.get(type_list[index]):
                            flag = False
                            break
                    elif mask == '1':
                        if not components.get(type_list[index]):
                            flag = False
                            break
                if flag:
                    cve_list.append(cve)
        
        save_text(file_path, cve_list)
        save_pickle(f'{file_path}.pkl', cve_list)
        return cve_list


    def select_by_file_component(self, k: int, cve_list: list = None, similarity_algorithm = difflib.SequenceMatcher):
        if not cve_list:
            cve_list = self.filter_cve_list('212')
        res_path = f'{self.module_root_path}/candidates_with_File_component_{len(cve_list)}_{k}_{similarity_algorithm.__name__}.json'
        if os.path.exists(res_path):
            return load_json(res_path)

        res = {}
        for cve in tqdm.tqdm(cve_list):
        # for cve in random.sample(cve_list, 50):
            file_components = self.cve_data_all[cve].get('components').get('File')
            collected_commit = self.cve_data_all[cve].get('collected_commit')

            res[cve] = {}
            for repo, commit in collected_commit:
                repo_file_list = self.repo_file_list[repo][commit]
                related_files = self.find_related_files(file_components, repo_file_list, k, similarity_algorithm)
                res[cve][repo] = related_files
        
        save_json(res_path, res)
        return res
    

    def check_accuracy(self, data: dict, size: int):
        correct_count = 0
        total_count = 0
        # over_1_count = 0
        for cve, v in data.items():
            # if not self.cve_data_all[cve]['collected_repo_correction']: continue
            # if not self.cve_data_all[cve]['collected_commit_correction']: continue

            total_count += 1
            flag = False
            for _, triple_list in v.items():
                if flag:
                    break
                ans_list = self.cve_data_all[cve]['files']
                for index, (_, file, similarity) in enumerate(triple_list):
                    if index >= size and similarity != triple_list[index - 1][2]:
                        # if index > 1:
                        #     print(cve, index)
                        #     over_1_count += 1
                        break
                    if (any(file.lower() == ans.lower() for ans in ans_list)):
                        flag = True
                        break
            if flag:
                correct_count += 1
        
        print(size, ':{:.2f}%'.format(correct_count / total_count * 100), f'({correct_count}/{total_count})')
        # print(over_1_count)
        # print(size, ':{:.2f}%'.format(correct_count / total_count * 100), f'({correct_count}/{total_count})')


    def find_related_files(self, keywords: list, files: list, k: int, similarity_algorithm):
        # components中包含/则匹配完整路径，否则只匹配文件名
        res = []
        for keyword in keywords:
            for file, isdir in files:
                if isdir: continue
                file_lower = file.lower()
                keyword_lower = keyword.lower()
                # if any(element in file_lower for element in self.filter_file_pattern): continue
                # if any(file_lower.endswith(element) for element in self.filter_list_suffix): continue

                if '/' not in keyword:
                    keyword_lower = keyword.split('/')[-1]
                    file_lower = file.split('/')[-1]
                
                if similarity_algorithm.__name__ == 'SequenceMatcher':
                    similarity = difflib.SequenceMatcher(None, keyword_lower, file_lower).ratio()
                elif similarity_algorithm.__name__ == 'ngram_similarity':
                    similarity = ngram_similarity(keyword_lower, file_lower, 2)
                else:
                    similarity = similarity_algorithm(keyword_lower, file_lower)
                res.append((keyword, file, similarity))
        sorted_res = sorted(res, key = lambda x: x[2], reverse = (similarity_algorithm.__name__ != 'levenshtein_distance'))
        # sorted_res = sorted(res, key = lambda x: x[2])
        return sorted_res[:k]