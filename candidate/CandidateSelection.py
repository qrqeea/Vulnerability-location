import os
import tqdm
import random
import difflib
from util import *

class CandidateSelection:

    def __init__(self, project_root_path: str, module_root_path: str, cve_data_all: dict, repo_file_list: dict):
        self.project_root_path = project_root_path
        self.module_root_path = module_root_path
        self.cve_data_all = cve_data_all
        self.repo_file_list = repo_file_list

        os.makedirs(self.module_root_path, exist_ok = True)


    def start(self):
        # res = self.select_by_component('File')
        # res = self.select_by_component('Module')
        # res = self.select_by_component('Function')
        # self.check_accuracy(res, 1)
        # self.check_accuracy(res, 2)
        # self.check_accuracy(res, 3)
        # self.check_accuracy(res, 4)
        # self.check_accuracy(res, 5)
        # self.check_accuracy(res, 10)
        # self.check_accuracy(res, 50)

        res = self.select_by_module_and_function('Function')


    def filter_cve_list(self, component_type: str):
        path = f'{self.module_root_path}/cve_list_with_{component_type}_component.pkl'
        if os.path.exists(path):
            return load_pickle(path)
        
        cve_list = []
        for cve, v in self.cve_data_all.items():
            components = v.get('components')
            if components:
                file_components = components.get(component_type)
                collected_commit = v.get('collected_commit')
                if file_components and collected_commit:
                    cve_list.append(cve)
        save_pickle(path, cve_list)
        return cve_list


    def select_by_component(self, component_type: str):
        res_path = f'{self.module_root_path}/candidates_with_{component_type}_component_50.json'
        if os.path.exists(res_path):
            return load_json(res_path)

        def select_by_component_sub(cve_list_sub: list):
            for cve in tqdm.tqdm(cve_list_sub):
            # for cve in random.sample(cve_list, 5):
            # for cve in ['CVE-2018-15178']:
                file_components = self.cve_data_all[cve].get('components').get(component_type)
                collected_commit = self.cve_data_all[cve].get('collected_commit')

                res[cve] = {}
                for repo, commit in collected_commit:
                    repo_file_list = self.repo_file_list[(repo, commit)]
                    related_files = self.find_related_files(component_type, file_components, repo_file_list)
                    res[cve][repo] = related_files

        cve_list = self.filter_cve_list(component_type)

        res = {}
        multi_thread(cve_list, select_by_component_sub, chunk_size = 500)
        # multi_thread(random.sample(cve_list, 10), select_by_component_sub, chunk_size = 50)
        save_json(res_path, res)
        return res
    

    def check_accuracy(self, data: dict, size: int):
        count = 0
        for cve, v in data.items():
            flag = False
            for _, triple_list in v.items():
                file_list = [item[1] for item in triple_list[:size]]
                ans_list = self.cve_data_all[cve]['files']
                if (any(file.lower() == ans.lower() for file in file_list for ans in ans_list)):
                    flag = True
                    # print(cve)
                    break
            if flag:
                count += 1
        
        print(size, ':{:.2f}%,'.format(count / len(data) * 100), f'{count}/{len(data)}')        


    def find_related_files(self,  component_type: str, keywords, files, count = 50):
        # components中包含/则匹配完整路径，否则只匹配文件名
        res = []
        for keyword in keywords:
            for file in files:
                if component_type == 'File':
                    if '/' in keyword:
                        keyword_update = keyword.lower()
                        file_update = file.lower()
                    else:
                        keyword_update = keyword.split('/')[-1].lower()
                        file_update = file.split('/')[-1].lower()
                elif component_type == 'Module':
                    keyword_update = keyword.lower()
                    file_update = file.lower()
                elif component_type == 'Function':
                    keyword_update = keyword.lower()
                    file_update = file.lower()
                similarity = difflib.SequenceMatcher(None, keyword_update, file_update).ratio()
                res.append((keyword, file, similarity))
        sorted_res = sorted(res, key = lambda x: x[2], reverse = True)
        return sorted_res[:count]
    

    def select_by_module_and_function(self):
        pass