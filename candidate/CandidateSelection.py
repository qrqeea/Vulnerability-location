import os
import sys
import ast
import tqdm
import random
from util.io_util import *
from util.general_util import *
from util.similarity_util import *
from .FileSelection import FileSelection
from .FunctionSelection import FunctionSelection
from .ModuleSelection import ModuleSelection


class CandidateSelection:

    def __init__(self, module_root_path: str, gt_content_path: str, repo_path: str, cve_data_all: dict, repo_file_list: dict):
        self.module_root_path = module_root_path
        self.gt_content_path = gt_content_path
        self.repo_path = repo_path
        self.cve_data_all = cve_data_all
        self.repo_file_list = repo_file_list

        os.makedirs(self.module_root_path, exist_ok = True)

        # self.candidate_content_dir = f'{self.module_root_path}/candidate_content'
        # os.makedirs(self.candidate_content_dir, exist_ok = True)

        self.file_component_dir = f'{self.module_root_path}/file'
        self.function_component_dir = f'{self.module_root_path}/function'
        self.module_component_dir = f'{self.module_root_path}/module'

        self.prompt_dir = f'{self.module_root_path}/prompt'
        os.makedirs(self.prompt_dir, exist_ok = True)
        
        self.result_dir = f'{self.module_root_path}/result'
        os.makedirs(self.result_dir, exist_ok = True)


    def start(self):
        # self.get_filtered_files()
        # self.generate_prompt()
        # self.count_total_token()
        self.get_candidates()
        # self.check_candidates_recall()

    
    def get_filtered_files(self):
        fileSelection = FileSelection(
            module_root_path = self.file_component_dir,
            cve_data_all = self.cve_data_all,
            repo_file_list = self.repo_file_list
        )
        file_res, cve_list_done = fileSelection.retrieve(3, 0.7)
        # self.check_recall(file_res)
        # print(233, len(cve_list_done))
        
        functionSelection = FunctionSelection(
            module_root_path = self.function_component_dir,
            repo_path = self.repo_path,
            cve_data_all = self.cve_data_all,
            cve_list_done = cve_list_done
        )
        function_res = functionSelection.retrieve()
        # self.check_recall(function_res)

        # self.check_recall(self.union_result([file_res, function_res]))
        
        # save_pickle(f'{self.module_component_dir}/cve_list_5924.pkl', cve_list_done)
        cve_list_done = load_pickle(f'{self.module_component_dir}/cve_list_5924.pkl')

        # cve_list_done = list(set(file_res.keys() | set(function_res.keys())))
        # print(233, len(cve_list_done))
        moduleSelection = ModuleSelection(
            module_root_path = self.module_component_dir,
            repo_path = self.repo_path,
            cve_data_all = self.cve_data_all,
            cve_list_done = cve_list_done,
            repo_file_list = self.repo_file_list
        )
        module_res = moduleSelection.retrieve()
        # self.check_recall(module_res)

        union_res = self.union_result([file_res, function_res, module_res])
        self.check_recall(union_res)


    def generate_prompt(self):
        res = load_pickle(f'{self.module_root_path}/filtered_files.pkl')
        filter_incorrect_cve_list = load_pickle(f'{self.module_root_path}/filter_incorrect_cve_list.pkl')
        # count = []
        # for cve, v in res.items():
        #     if len(v) != 1:
        #         print('error', cve)
        #     for repo, files in v.items():
        #         count.append(len(files))
        # print(count_range(count, [1, 2, 5, 10, 100, 500, 1000, 2000, 3000, 4000, 5000, 15000]))
        
        prompt_template = load_file(f'{self.module_root_path}/prompt_select_candidates')
        for cve, v in res.items():
            for _, files in v.items():
                if len(files) == 1 or cve in filter_incorrect_cve_list:
                    continue
                prompt = prompt_template.replace(
                    '{vulnerability description}',
                    self.cve_data_all[cve]['complete_description'] if 'complete_description' in self.cve_data_all[cve] else self.cve_data_all[cve]['original_description']
                    ).replace(
                        '{file list}',
                        str(files)
                    )
                save_text(f'{self.prompt_dir}/{cve}', prompt)
        

    def get_candidates(self):
        prompt_files = os.listdir(f'{self.module_root_path}/prompt')
        if '.DS_Store' in prompt_files:
            prompt_files.remove('.DS_Store')

        def get_candidates_sub(prompt_files_sub: list):
            for file in tqdm.tqdm(prompt_files_sub):
            # for file in tqdm.tqdm(random.sample(prompt_files_sub, 1)):
                if os.path.exists(f'{self.result_dir}/{file}'):
                    continue
                prompt = load_file(f'{self.prompt_dir}/{file}')
                if calc_token(prompt) > 16385:
                    continue
                try:
                    res = query_openai(prompt)    # model = 'gpt-4o-2024-05-13'
                    save_text(f'{self.result_dir}/{file}', res)
                except Exception as e:
                    save_text(f'{self.result_dir}/error_list', f'{file}\n\n{e}', 'a')

        multi_thread(prompt_files, get_candidates_sub, chunk_size = 800)


    def count_total_token(self):
        total = 0
        for file in tqdm.tqdm(os.listdir(self.prompt_dir)):
            if file in ['.DS_Store']: continue
            token = calc_token(load_file(f'{self.prompt_dir}/{file}'))
            if token > 16385:
                print(file, token)
            total += token
        token_M = int(total / 1000000)
        print(f'total token: {token_M}M, price: {token_M * 0.5}$')


    def check_candidates_recall(self):
        result_files = os.listdir(f'{self.module_root_path}/result')
        if '.DS_Store' in result_files:
            result_files.remove('.DS_Store')
        total_count = 0
        correct_cnt = 0
        incorrect_cve_list = []
        for file in result_files:
            try:
                res = load_file(f'{self.result_dir}/{file}')
                res = ast.literal_eval(res)
                # res = list(set(res))
                # with open(f'{self.result_dir}/{file}', 'w') as f:
                #     print(res, file = f)
                total_count += 1
                vul_file = self.cve_data_all[file]['collected_commit'][2]
                if vul_file in res:
                    correct_cnt += 1
                else:
                    incorrect_cve_list.append(file)
                    # print('vul_file:', vul_file)
                    # print(res)
                    # print(f'{self.prompt_dir}/{file}')
                    # print(f'{self.result_dir}/{file}')
                    # print('____________________________________')
            except Exception as e:
                print(f'{self.result_dir}/{file}')
                # save_text(f'{self.result_dir}/parser_error_list', f'{file}\n\n{e}', 'a')
                # with open(f'{self.result_dir}/{file}', 'r') as f:
                #     data = f.readlines()
                #     res = []
                #     for i in data:
                #         i = i.strip()
                #         if i != '```':
                #             res.append(i.strip())
                # with open(f'{self.result_dir}/{file}', 'w') as f:
                #     print(res, file = f)
        
        print('{:.2f}%'.format(correct_cnt / total_count * 100), f'({correct_cnt}/{total_count})')
        correct_cnt = 6034 - len(incorrect_cve_list) - 595
        print('total: {:.2f}%'.format(correct_cnt / 6034 * 100), f'({correct_cnt}/{6034})')
        save_text(f'{self.module_root_path}/retry_cve_list', incorrect_cve_list)
        save_pickle(f'{self.module_root_path}/retry_cve_list.pkl', incorrect_cve_list)


    def union_result(self, dict_list: list):
        res_path = f'{self.module_root_path}/filtered_files'
        if os.path.exists(f'{res_path}.pkl'):
            return load_pickle(f'{res_path}.pkl')
        res = {}
        for dict in dict_list:
            for cve, v in dict.items():
                for repo, files in v.items():
                    if cve not in res:
                        res[cve] = {}
                    if repo not in res[cve]:
                        res[cve][repo] = files
                    else:
                        res[cve][repo] = list(set(res[cve][repo]) | set(files))
        save_json(f'{res_path}.json', res)
        save_pickle(f'{res_path}.pkl', res)
        return res


    def check_recall(self, data: dict):
        incorrect_cve_list = []
        for cve, v in data.items():
            flag = False
            vul_file = self.cve_data_all[cve]['collected_commit'][2]
            for _, file_candidates in v.items():
                if vul_file in file_candidates:
                    flag = True
            if not flag:
                incorrect_cve_list.append(cve)
        
        total_count = len(data)
        correct_cnt = total_count - len(incorrect_cve_list)
        save_text(f'{self.module_root_path}/filter_incorrect_cve_list', incorrect_cve_list)
        save_pickle(f'{self.module_root_path}/filter_incorrect_cve_list.pkl', incorrect_cve_list)
        print('{:.2f}%'.format(correct_cnt / total_count * 100), f'({correct_cnt}/{total_count})')