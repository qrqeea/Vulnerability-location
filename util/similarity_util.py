import math
from collections import Counter
# from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer


def levenshtein_distance(s1, s2):
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)
    
    if len(s2) == 0:
        return len(s1)
    
    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]     # 越小越好


def jaccard_similarity(s1, s2):
    set1 = set(s1)
    set2 = set(s2)
    intersection = len(set1.intersection(set2))
    union = len(set1.union(set2))
    # print(intersection)
    # print(union)
    return intersection / union if union != 0 else 0    # 越大越好


# def cosine_similarity(s1, s2):
#     counter1 = Counter(s1)
#     counter2 = Counter(s2)
    
#     intersection = sum(counter1[c] * counter2[c] for c in counter1 if c in counter2)
#     magnitude1 = math.sqrt(sum(counter1[c] ** 2 for c in counter1))
#     magnitude2 = math.sqrt(sum(counter2[c] ** 2 for c in counter2))
    
#     return intersection / (magnitude1 * magnitude2) if magnitude1 != 0 and magnitude2 != 0 else 0   # 越大越好


def tfidf_similarity(s1, s2):
    vectorizer = TfidfVectorizer(analyzer='char')
    tfidf_matrix = vectorizer.fit_transform([s1, s2])
    similarity = cosine_similarity(tfidf_matrix[0], tfidf_matrix[1])
    return similarity[0][0]

# # 示例
# filename1 = "file1.txt"
# filename2 = "file2.txt"
# similarity = tfidf_similarity(filename1, filename2)
# print("TF-IDF 相似度:", similarity)


def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]


def lcs_similarity(s1, s2):
    lcs_length = longest_common_subsequence(s1, s2)
    max_length = max(len(s1), len(s2))
    return lcs_length / max_length if max_length != 0 else 0    # 越大越好


def ngram_similarity(s1, s2, n):
    set1 = set([s1[i:i+n] for i in range(len(s1)-n+1)])
    set2 = set([s2[i:i+n] for i in range(len(s2)-n+1)])
    intersection = len(set1.intersection(set2))
    union = len(set1.union(set2))
    return intersection / union if union != 0 else 0
