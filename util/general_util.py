import math
import requests
import threading
from urllib.parse import urlparse


# 文件名相同
filter_file = [
    'changelog', 'news', 'changes', 'version', 'readme', 'license', 'authors', 'todo', 'history', 'copying', 'relnotes', 'thanks', 'notice', 'whatsnew', 'notes', 'release', 'release_notes', 'testlist', 'testsuite', 'test'
]
# 以这些后缀结尾的文件
filter_suffix = [
    '.md', '.txt', '.docx', '.pdf', '.rst', '.changes', '.rdoc', '.mdown',
    '.command', '.out', '.err', '.stderr', '.stdout', '.test',
    '.jpg', '.png', '.svg', '.mp4', '.gif', '.exr',
    '.csv', '.rdf',
    '.ttf', '.otf', '.woff', '.woff2',
    '.mock', '.stub', '.fake',
    '.pptx', '.key',
    '.bak', '.zip', '.gz', '.rar',
    '.gitignore',
    '.lib', '.jpeg', '.ppt', '.xlsx', '.xls', '.doc', '.ico', '.bmp', '.tar.gz', '.tgz', '.css', '.cygport',
    '.docs', '.wav'
]
# 路径中包含
filter_path = [
    'note', 'license', 'test'
]


def rule_based_filtering(full_file_name: str):
    full_file_name = full_file_name.lower()
    file_name = full_file_name.split('/')[-1]
    file_path = '/'.join(full_file_name.split('/')[:-1])
    if any(file_name == item for item in filter_file):
        return False
    if any(file_name.endswith(suffix) for suffix in filter_suffix):
        return False
    if any(item in file_path for item in filter_path):
        return False
    return True


def get_domain(url):
    parsed_url = urlparse(url)
    return parsed_url.netloc


def count_range(data: list, interval: list):
    res = {}
    for i in range(len(interval)):
        if i == 0:
            res[f'1-{interval[0]}'] = 0
        if i == len(interval) - 1:
            res[f'>{interval[-1]}'] = 0
            continue
        else:
            l = interval[i] + 1
            r = interval[i + 1]
            res[f'{l}-{r}'] = 0

    for item in data:
        for i, value in enumerate(interval):
            if (i == 0 and item <= value) or (i == len(interval) - 1) or (item <= interval[i + 1]):
                if i == 0 and item <= value:
                    res[f'1-{value}'] += 1
                elif i == len(interval) - 1:
                    res[f'>{value}'] += 1
                else:
                    res[f'{value + 1}-{interval[i + 1]}'] += 1
                break
    return res


def format_text(text: str, separator = '\n'):
    lines = text.split('\n')

    # 去除每行前后的空格，并过滤掉空行
    stripped_lines = [line.strip() for line in lines if line.strip()]

    result = separator.join(stripped_lines)
    return result


def multi_thread(data_list: list, target, chunk_size = 300, tokens = None):
    if tokens:
        chunk_size = max(1, math.ceil(len(data_list) / len(tokens)))
    chunks = [data_list[i:i + chunk_size] for i in range(0, len(data_list), chunk_size)]

    threads = []
    for i in range(len(chunks)):
        if tokens:
            args = (chunks[i], tokens[i],)
        else:
            args = (chunks[i],)
        thread = threading.Thread(target = target, args = args)
        threads.append(thread)
    
    for thread in threads:
        thread.start()

    for thread in threads:
        thread.join()


def get_redirected_url(url):
    response = requests.head(url, allow_redirects = True)
    return response.url


def clear_comment(content: str):
    while True:
        l = content.find('/*')
        r = content.find('*/')
        if l != -1 and r != -1 and r > l:
            content = content[:l] + content[r + 2:]
        else:
            return content