import os
import tqdm
import difflib
import random
import pandas as pd
from util.io_util import *
from util.github_util import *


class TrainingSet:

    def __init__(self, project_root_path: str, module_root_path: str, cve_data_all: dict, cve_list: list, positive_label_list: list, repo_file_list: dict):
        self.project_root_path = project_root_path
        self.module_root_path = module_root_path
        self.cve_data_all = cve_data_all
        self.cve_list = cve_list
        self.positive_label_list = positive_label_list
        self.repo_file_list = repo_file_list

        os.makedirs(module_root_path, exist_ok = True)

        # 文件名相同
        self.filter_file = [
            'changelog', 'news', 'changes', 'version', 'readme', 'license', 'authors', 'todo', 'history', 'copying', 'relnotes', 'thanks', 'notice', 'whatsnew', 'notes', 'release_notes', 'testlist', 'testsuite', 'test'
        ]
        # 以这些后缀结尾的文件
        self.filter_suffix = [
            '.md', '.txt', '.docx', '.pdf', '.rst', '.changes', '.rdoc', '.mdown',
            '.command', '.out', '.err', '.stderr', '.stdout', '.test',
            '.jpg', '.png', '.svg', '.mp4', '.gif', '.exr',
            '.csv', '.rdf',
            '.ttf', '.otf', '.woff', '.woff2',
            '.mock', '.stub', '.fake',
            '.pptx', '.key',
            '.bak', '.zip', '.gz', '.rar',
            '.gitignore',
            '.lib', '.jpeg', '.ppt', '.xlsx', '.xls', '.doc', '.ico', '.bmp', '.tar.gz', '.tgz', '.css', '.cygport',
            '.docs', '.wav'
        ]
        # 路径中包含
        self.filter_path = [
            'note', 'license', 'test'
        ]


    def start(self):
        self.select_training_and_test_set()
        # self.generate_training_set()


    def select_training_and_test_set(self):
        res = self.random_split(self.positive_label_list, 5)
        for i in range(5):
            # res[i]作为测试集
            test_set_pos = res[i]
            training_set_pos = []
            for j in range(5):
                if i != j:
                    training_set_pos += res[j]
            print(len(test_set_pos), len(training_set_pos))
            training_set_neg = []
            while len(training_set_neg) < len(training_set_pos):
                for cve, _, _ in tqdm.tqdm(training_set_pos):
                    rd = self.random_select_one_file(cve)
                    if rd:
                        training_set_neg.append(rd)
                        if len(training_set_neg) == len(training_set_pos):
                            break

            test_set_neg = []
            incorrect_cve = list(set(self.cve_list) - {cve for cve, _, _ in self.positive_label_list})
            # print(len(incorrect_cve))   # 534
            tp = [cve for cve, _, _ in test_set_pos] + incorrect_cve
            while len(test_set_neg) < len(test_set_pos) * 100:
                for cve in tqdm.tqdm(tp):
                    rd = self.random_select_one_file(cve)
                    if rd:
                        test_set_neg.append(rd)
                        if len(test_set_neg) == len(test_set_pos) * 100:
                            break
            
            training_set = training_set_pos + training_set_neg
            test_set = test_set_pos + test_set_neg
            save_text(f'{self.module_root_path}/training_set_{i}', training_set)
            save_text(f'{self.module_root_path}/test_set_{i}', test_set)


    def random_select_one_file(self, cve: str):
        for repo, sha in self.cve_data_all[cve]['collected_commit']:
            cnt = 0
            while True:
                # random.seed()
                file, isdir = random.choice(self.repo_file_list[repo][sha])
                # print(file, isdir)
                file_lower = file.lower()
                path = '/'.join(file_lower.split('/')[:-1])
                if not isdir and not any(file_lower.split('/')[-1] == item for item in self.filter_file) and not any(file_lower.endswith(suffix) for suffix in self.filter_suffix) and not any(item in path for item in self.filter_path):
                    return (cve, repo, file)
                cnt += 1
                if cnt > 50:    # 经过规则筛选后没有文件了
                    return None


    def random_split(self, data: list, parts: int):
        random.shuffle(data)
        block_size = int(len(data) / parts)
        res = []
        for i in range(parts):
            l = i * block_size
            r = l + block_size
            if i == parts - 1:
                r = len(data)
            res.append(data[l:r])
        return res


    def generate_training_set(self):
        df = pd.DataFrame({
            'sentence': [],
            'label': [],
        })
        for cve in self.cve_list:
            for repo in self.cve_data_all[cve]['collected_repo']:
                repo_updated = repo.replace('/', '—')
                repo_path = f'{self.repo_path}/{cve}/{repo_updated}'
                if not os.path.exists(repo_path):
                    print(f'repo not exist: {cve} {repo}')
                    continue
                    # sys.exit()
                for root, _, files in os.walk(repo_path):
                    for file in files:
                        # TODO 启发式规则筛选
                        full_path = f'{root}/{file}'
                        try:
                            content = format_text(load_file(full_path), ' ')
                            content = content[:400] # TODO 裁剪
                            desc = self.cve_data_all[cve]['complete_description'] if 'complete_description' in self.cve_data_all[cve] else self.cve_data_all[cve]['original_description']
                            desc = desc[:100]       # TODO 裁剪
                            file_path = full_path.split(f'{repo_updated}/')[-1]
                            label = 1 if repo in self.cve_data_all[cve]['vulnerability_files'] and file_path in self.cve_data_all[cve]['vulnerability_files'][repo] else 0
                            # TODO label
                            df.loc[len(df)] = [
                                f'{repo} <|endoftext|> {file_path} <|endoftext|> {desc} <|endoftext|> {content}',
                                label
                            ]
                        except Exception as e:
                            pass
                df.to_csv(
                    f'{self.module_root_path}/training_set.csv',
                    index = False,
                )
                sys.exit()