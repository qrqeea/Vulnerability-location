import os
import csv
import tqdm
import pandas as pd
from util.io_util import *
from util.github_util import *


class TrainingSet:

    def __init__(self, project_root_path: str, module_root_path: str, repo_path: str, cve_data_all: dict, cve_list: list, repo_file_list: dict):
        self.project_root_path = project_root_path
        self.module_root_path = module_root_path
        self.repo_path = repo_path
        self.cve_data_all = cve_data_all
        self.cve_list = cve_list
        self.repo_file_list = repo_file_list

        os.makedirs(module_root_path, exist_ok = True)


    def start(self):
        self.get_positive_sample()
        # self.generate_training_set()

    
    def get_positive_sample(self):
        total_cnt = 0
        correct_cnt = 0
        repo_correct_cnt = 0
        for cve in tqdm.tqdm(self.cve_list):
            flag = False
            total_cnt += 1
            for repo in self.cve_data_all[cve]['collected_repo']:
                if flag: break
                if repo not in self.cve_data_all[cve]['vulnerability_files']:
                    continue
                repo_correct_cnt += 1
                sha = ''
                for repo2, sha2 in self.cve_data_all[cve]['collected_commit']:
                    if repo == repo2:
                        sha = sha2
                        break
                if not sha:
                    print(f'error: {cve} {repo} not found sha')
                    sys.exit()
                for file in self.cve_data_all[cve]['vulnerability_files'][repo]:
                    if (file, False) in self.repo_file_list[repo][sha]:
                        flag = True
                        break
            if flag:
                correct_cnt += 1
        
        print(f'correct_cnt: {correct_cnt}')
        print(f'repo_correct_cnt: {repo_correct_cnt}')
        print(f'total_cnt: {total_cnt}')
    

    def generate_training_set(self):
        df = pd.DataFrame({
            'sentence': [],
            'label': [],
        })
        for cve in self.cve_list:
            for repo in self.cve_data_all[cve]['collected_repo']:
                repo_updated = repo.replace('/', '—')
                repo_path = f'{self.repo_path}/{cve}/{repo_updated}'
                if not os.path.exists(repo_path):
                    print(f'repo not exist: {cve} {repo}')
                    continue
                    # sys.exit()
                for root, _, files in os.walk(repo_path):
                    for file in files:
                        # TODO 启发式规则筛选
                        full_path = f'{root}/{file}'
                        try:
                            content = format_text(load_file(full_path), ' ')
                            content = content[:400] # TODO 裁剪
                            desc = self.cve_data_all[cve]['complete_description'] if 'complete_description' in self.cve_data_all[cve] else self.cve_data_all[cve]['original_description']
                            desc = desc[:100]       # TODO 裁剪
                            file_path = full_path.split(f'{repo_updated}/')[-1]
                            label = 1 if repo in self.cve_data_all[cve]['vulnerability_files'] and file_path in self.cve_data_all[cve]['vulnerability_files'][repo] else 0
                            # TODO label
                            df.loc[len(df)] = [
                                f'{repo} <|endoftext|> {file_path} <|endoftext|> {desc} <|endoftext|> {content}',
                                label
                            ]
                        except Exception as e:
                            pass
                df.to_csv(
                    f'{self.module_root_path}/training_set.csv',
                    index = False,
                )
                sys.exit()