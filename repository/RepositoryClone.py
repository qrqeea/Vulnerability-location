import tqdm
import random
from util import *
from common.github_util import *


class RepositoryClone:

    def __init__(self, module_root_path: str, cve_data_all: dict):
        self.module_root_path = module_root_path
        self.cve_data_all = cve_data_all

        self.cloned_repo_dir = f'{self.module_root_path}/repo_all'
        os.makedirs(self.cloned_repo_dir, exist_ok = True)

        self.target_dir = f'{self.module_root_path}/target'
        os.makedirs(self.target_dir, exist_ok = True)


    def start(self):
        self.clone_all_repo()
        specified_repo_list = [ 
            (cve, repo, sha)
            for cve, v in self.cve_data_all.items()
            if v.get('collected_commit')
            for repo, sha in v['collected_commit']
        ]
        # print(len(specified_repo_list))     # 4698
        self.clone_specified_repo(specified_repo_list)
        repo_file_list = self.clone_specified_repo_file_list()
        error_list = self.verify_specified_repo(repo_file_list)
        self.clone_specified_repo(error_list)

    
    def clone_all_repo(self):
        repo_all = {repo for v in self.cve_data_all.values() if v.get('collected_repo') for repo in v['collected_repo']}
        # print(len(repo_all))        # 2054

        for repo_full_name in tqdm.tqdm(repo_all):
            # print(repo_full_name)
            repo_full_name_updated = repo_full_name.replace('/', '—')
            # print(repo_full_name_updated)

            dest_dir = f'{self.cloned_repo_dir}/{repo_full_name_updated}'
            if os.path.exists(dest_dir):
                continue
            # cmd = f'git clone --depth=1 {url}.git {path}/{repo_full_name_updated}'
            cmd = f'git clone --depth=1 git@github.com:{repo_full_name}.git {dest_dir}'
            if os.system(cmd) != 0:
                save_text(f'{self.cloned_repo_dir}/error_list', repo_full_name, 'a')

    
    def clone_specified_repo(self, data: list):
        for cve, repo, sha in tqdm.tqdm(data):
            
            dir_name = f'{self.target_dir}/{cve}'
            # print('dir_name:', dir_name)
            os.makedirs(dir_name, exist_ok = True)

            repo_full_name_updated = repo.replace('/', '—')
            dest_path_repo = f'{dir_name}/{repo_full_name_updated}'

            if os.path.exists(dest_path_repo):
                print('start delete original data')
                shutil.rmtree(dest_path_repo)
                print('end delete original data')
                
            source_path_repo = f'{self.cloned_repo_dir}/{repo_full_name_updated}'

            cmd1 = f'cd {source_path_repo} && git fetch origin {sha} --depth=1 1>/dev/null'
            cmd2 = f'cd {source_path_repo} && git clean -fd && git checkout . 1>/dev/null'
            cmd3 = f'cd {source_path_repo} && git checkout {sha} 1>/dev/null'
            print('run cmd1')
            if os.system(cmd1) != 0:
                save_text(f'{self.target_dir}/error_list', f'cmd1, {cve}, {repo}', 'a')
                print('cmd1 error')
                continue
            print('run cmd2')
            if os.system(cmd2) != 0:
                save_text(f'{self.target_dir}/error_list', f'cmd2, {cve}, {repo}', 'a')
                print('cmd2 error')
                continue
            print('run cmd3')
            if os.system(cmd3) != 0:
                save_text(f'{self.target_dir}/error_list', f'cmd3, {cve}, {repo}', 'a')
                print('cmd3 error')
                continue

            if not os.path.exists(dest_path_repo):
                os.mkdir(dest_path_repo)

            cmd = f"rsync -a --exclude='.git' {source_path_repo} {dir_name}"
            
            print('run cmd4')
            if os.system(cmd) != 0:
                save_text(f'{self.target_dir}/error_list', f'cmd4, {cve}, {repo}', 'a')
                print('cmd4 error')
        

    def clone_specified_repo_file_list(self):
        res_path = f'{self.module_root_path}/repo_file_list'
        if os.path.exists(res_path):
            return load_pickle(f'{res_path}.pkl')
        
        def clone_specified_repo_file_list_sub(cve_list_sub: list, token: str):
            for (repo, sha) in tqdm.tqdm(cve_list_sub):
                repo_file_list[(repo, sha)] = get_file_list(repo, sha, token)

        repo_file_list = {}

        data_list = list({
            (repo, sha)
            for v in self.cve_data_all.values()
            if v.get('collected_commit')
            for (repo, sha) in v['collected_commit']
        })
        # print(len(data_list))       # 3528
        multi_thread(data_list, clone_specified_repo_file_list_sub, tokens = github_tokens)

        save_text(res_path, repo_file_list)
        save_pickle(f'{res_path}.pkl', repo_file_list)

        return repo_file_list


    def verify_specified_repo(self, repo_file_list: dict):
        total_count = 0
        error_count = 0
        error_list = []
        for cve, v in tqdm.tqdm(self.cve_data_all.items()):
            if not v.get('collected_commit'): continue
            
            for repo, sha in v['collected_commit']:
                total_count += 1
                repo_updated = repo.replace('/', '—')
                path = f'{self.target_dir}/{cve}/{repo_updated}'
                if not os.path.exists(path):
                    # save_text(f'{self.module_root_path}/error_list', f'{cve} {repo} not exist', 'a')
                    error_list.append((cve, repo, sha))
                    error_count += 1
                    continue
                for file_path, _ in repo_file_list[(repo, sha)]:
                    if not os.path.islink(file_path) and not os.path.exists(f'{path}/{file_path}'):
                        error_list.append((cve, repo, sha))
                        # save_text(f'{self.module_root_path}/error_list', f'{path}/{file_path} not exist', 'a')
                        error_count += 1
                        break
        print(f'total_count: {total_count}, error_count: {error_count}')

        save_text(f'{self.module_root_path}/specified_repo_error_list', error_list)
        save_pickle(f'{self.module_root_path}/specified_repo_error_list.pkl', error_list)
        return error_list