import os
import tqdm
import random
import requests
from datetime import datetime
from util.io_util import *
from util.github_util import *


class RepositoryCollection:

    def __init__(self, project_root_path: str, module_root_path: str, cve_data_all: dict):
        self.project_root_path = project_root_path
        self.module_root_path = module_root_path
        self.cve_data_all = cve_data_all
        
        # 这个模块的target cve list是提取到任意一种组件的cve（之后会删减, 多收集一点也没事）
        self.cve_list = [k for k, v in self.cve_data_all.items() if 'components' in v]
        # self.cve_list = random.sample(self.cve_list, 100)

        self.repo_from_gpt = f'{self.module_root_path}/repo_from_gpt'
        os.makedirs(self.repo_from_gpt, exist_ok = True)

        self.repo_from_url = f'{self.module_root_path}/repo_from_url'
        os.makedirs(self.repo_from_url, exist_ok = True)

        self.repo_from_github = f'{self.module_root_path}/repo_from_github'
        os.makedirs(self.repo_from_github, exist_ok = True)


    def start(self):
        self.search_reference_url()
        self.check_result(self.repo_from_url)

        # self.query_gpt()
        # self.check_result(self.repo_from_gpt)

        # self.search_from_github()
        # self.check_result(self.repo_from_github)

        # self.union_result()

    def check_repo_existence(self, res: dict):
        
        def check_repo_existence_sub(cve_sub_list: list, token: str):
            for cve in tqdm.tqdm(cve_sub_list):
                repo_to_delete = []
                for repo in res[cve]:
                    if repo not in repo_existence_table:
                        repo_existence_table[repo] = check_repo_exist(repo, token)
                    if not repo_existence_table[repo]:
                        repo_to_delete.append(repo)
                for repo in repo_to_delete:
                    res[cve].remove(repo)
                if not res[cve]:
                    del res[cve]
                    # print('del', cve)

        # 检查提取到的repo是否存在
        print('start check if the repo exists')
        
        if os.path.exists(f'{self.module_root_path}/repo_existence_table.json'):
            repo_existence_table = load_json(f'{self.module_root_path}/repo_existence_table.json')
        else:
            repo_existence_table = {}
        
        multi_thread(list(res.keys()), check_repo_existence_sub, tokens = github_tokens)

        save_json(f'{self.module_root_path}/repo_existence_table.json', repo_existence_table)
        save_pickle(f'{self.module_root_path}/repo_existence_table.pkl', repo_existence_table)

        return res


    def search_reference_url(self):
        # 搜索cve的reference url, 如果有github url则提取repo
        print(f'start search reference url, cve count: {len(self.cve_list)}')
        
        res = {}
        for cve in tqdm.tqdm(self.cve_list):
            for url in self.cve_data_all[cve]['reference_list']:
                if get_domain(url) == 'github.com':
                    repo_full_name = '/'.join(url.split('/')[3:5])
                    if '#' in repo_full_name:
                        repo_full_name = repo_full_name[:repo_full_name.find('#')]
                    if cve in res:
                        res[cve].add(repo_full_name)
                    else:
                        res[cve] = {repo_full_name}
            if cve in res:
                res[cve] = list(res[cve])
        
        print(f'found {len(res)}/{len(self.cve_list)}, {len(self.cve_list) - len(res)} rest')
        print('end search reference url\n')

        res = self.check_repo_existence(res)

        save_json(f'{self.repo_from_url}/collected_repos.json', res)
        save_pickle(f'{self.repo_from_url}/collected_repos.pkl', res)
        
        print(f'found {len(res)}/{len(self.cve_list)}, {len(self.cve_list) - len(res)} rest')
        print('end check if the repo exists')


    def check_result(self, target: str):
        print('start check repo')

        incorrect_cve_dic = {}
        data = load_pickle(f'{target}/collected_repos.pkl')
        for cve, repos in tqdm.tqdm(data.items()):
            flag = False
            for repo in repos:
                if any(repo.lower() == ans.lower() for ans in self.cve_data_all[cve]['repos']):
                    flag = True
                    break
            if not flag:
                incorrect_cve_dic[cve] = repos
        print(f'first check: {len(incorrect_cve_dic)} cve incorrect')

        def get_latest_and_original_repo_name(repo_name: str, token: str):
            if repo_name not in repo_past_name_table:
                latest_repo_name = get_latest_repo_name(repo_name, token)
                original_repo_name = get_original_repo_name(repo_name, token)
                repo_past_name_table[repo_name] = {}
                repo_past_name_table[repo_name]['latest_name'] = latest_repo_name
                repo_past_name_table[repo_name]['original_name'] = original_repo_name
            return (
                repo_past_name_table[repo_name]['latest_name'],
                repo_past_name_table[repo_name]['original_name']
            )
        
        def check_repo_name(cve_list: list, token: str):
            for cve in tqdm.tqdm(cve_list):
                flag = False
                for repo in incorrect_cve_dic[cve]:
                    past_name = get_latest_and_original_repo_name(repo, token)
                    for repo_ans in self.cve_data_all[cve]['repos']:
                        ans_past_name = get_latest_and_original_repo_name(repo_ans, token)
                        if past_name[0].lower() == ans_past_name[0].lower() or past_name[1].lower() == ans_past_name[1].lower():
                            flag = True
                            break
                if flag:
                    del incorrect_cve_dic[cve]
        
        # 检查是否是改过名的或fork的repo
        if os.path.exists(f'{self.module_root_path}/repo_past_name_table.json'):
            repo_past_name_table = load_json(f'{self.module_root_path}/repo_past_name_table.json')
        else:
            repo_past_name_table = {}

        incorrect_cve_list = [cve for cve, _ in incorrect_cve_dic.items()]
        multi_thread(incorrect_cve_list, check_repo_name, tokens = github_tokens)

        if incorrect_cve_dic:
            save_json(f'{target}/incorrect_repo.json', incorrect_cve_dic)
            save_pickle(f'{target}/incorrect_repo.pkl', incorrect_cve_dic)
        
        save_json(f'{self.module_root_path}/repo_past_name_table.json', repo_past_name_table)
        save_pickle(f'{self.module_root_path}/repo_past_name_table.pkl', repo_past_name_table)

        print('accuracy: {:.2f}%,'.format((len(data) - len(incorrect_cve_dic)) / len(data) * 100), 
              f'{len(incorrect_cve_dic)} rest')
        print('end check repo')


    def search_from_github(self, target: str):
        # TODO 这里不一定能搜到repo，一些cve的repo可能为空

        def search(product_list_sub: list, token: str):
            for product in tqdm.tqdm(product_list_sub):
                tp = set()
                try:
                    params = {'q': product, 'per_page': 1}
                    search_res = search_repo(params, token)
                    tp |= search_res
                    # params = {'q': product, 'per_page': 5, 'sort': 'forks'}
                    # search_res = search_repo(params, token)
                    # tp |= search_res
                    # params = {'q': product, 'per_page': 5, 'sort': 'stars'}
                    # search_res = search_repo(params, token)
                    # tp |= search_res
                except Exception as e:
                    # print('token:', token)
                    print(e)
                product_search_res[product] = tp
        
        print('start search github')
        
        rest_cve_list = list(
            set(self.cve_list) - set(load_pickle(f'{self.repo_from_url}/collected_repos.pkl').keys()) -
            set(load_pickle(f'{self.repo_from_gpt}/collected_repos.pkl').keys())
        )
        print(len(rest_cve_list))

        product_list = list({ product for cve in rest_cve_list for product in self.cve_data_all[cve]['cpe_product'] })
        print(len(product_list))
        
        res = {}
        product_search_res = {}

        multi_thread(product_list, search, tokens = github_tokens)
        
        for cve in rest_cve_list:
            res[cve] = set()
            for product in self.cve_data_all[cve]['cpe_product']:
                res[cve] |= product_search_res[product]

        save_json(f'{self.repo_from_github}/collected_repos.json', res)
        save_pickle(f'{self.repo_from_github}/collected_repos.pkl', res)

        print(f'found {len(res)}/{len(rest_cve_list)}, {len(rest_cve_list) - len(res)} rest')
        print('end search github\n')


    def query_gpt(self):
        print('start query gpt')

        rest_cve_list = list(
            set(self.cve_list) - set(load_pickle(f'{self.repo_from_url}/collected_repos.pkl').keys())
        )
        print(len(rest_cve_list))

        # rest_cve_list = ['CVE-2017-2801', 'CVE-2019-11278', 'CVE-2021-3933', 'CVE-2019-1003003', 'CVE-2019-12617']
        # rest_cve_list = list(random.sample(rest_cve_list, 4))
        # print(rest_cve_list)

        os.makedirs(f'{self.repo_from_gpt}/prompt', exist_ok = True)
        os.makedirs(f'{self.repo_from_gpt}/result', exist_ok = True)
        
        print('start generate prompt')
        total_count = 0
        prompt_general = load_file(f'{self.repo_from_gpt}/prompt_query_repo')
        for cve in tqdm.tqdm(rest_cve_list):
            prompt = prompt_general.replace('{cve}', f'{cve}')
            cpe_uri = self.cve_data_all[cve]['cpe_uri'][0]
            prompt = prompt.replace('{cpe}', cpe_uri)
            total_count += calc_token(prompt, model = 'gpt-4-turbo')
            save_text(f'{self.repo_from_gpt}/prompt/{cve}', prompt)
        total_count_K = total_count / 1000
        print(f'end generate prompt, total token: {total_count_K}K, price: {0.01 * total_count_K}$')

        res = {}
        def query(cve_list_sub: list):
            for cve in tqdm.tqdm(cve_list_sub):
                res_path = f'{self.repo_from_gpt}/result/{cve}'
                if os.path.exists(res_path):
                    url = load_file(res_path).strip()
                else:
                    try:
                        prompt = load_file(f'{self.repo_from_gpt}/prompt/{cve}')
                        url = query_openai(prompt, model = 'gpt-4-turbo')
                        save_text(res_path, url)
                    except Exception as e:
                        save_text(f'{self.repo_from_gpt}/query_gpt_exception', f'{cve}\n{e}\n', 'a')
                        continue
                repo_full_name = self.extract_repo_name(url)
                if repo_full_name:
                    res[cve] = [repo_full_name]
                else:
                    save_text(f'{self.repo_from_gpt}/incorrect_list', cve, 'a')
        
        multi_thread(rest_cve_list, query, chunk_size = 300)
        res = self.check_repo_existence(res)

        save_json(f'{self.repo_from_gpt}/collected_repos.json', res)
        save_pickle(f'{self.repo_from_gpt}/collected_repos.pkl', res)

        print(f'get {len(res)}/{len(rest_cve_list)}, {len(rest_cve_list) - len(res)} rest')
        print('end query gpt\n')


    def extract_repo_name(self, repo_url):
        if repo_url.startswith('https://github.com/'):
            path_components: list = repo_url[len('https://github.com/'):].split('/')
            path_components = [item for item in path_components if item != '']  # 去除空元素

            if len(path_components) >= 2:
                return f"{path_components[0]}/{path_components[1]}"
        return None


    def union_result(self):
        path_list = [self.repo_from_url, self.repo_from_gpt, self.repo_from_github]
        res = {}
        for path in path_list:
            full_path = f'{path_list}/collected_repos.pkl'
            data = load_pickle(full_path)
            # print(len(data))
            res.update(data)
        # print(len(res))
        save_text(f'{self.module_root_path}/repo_collection', res)
        save_pickle(f'{self.module_root_path}/repo_collection.pkl', res)
        
        for cve, repos in res.items():
            self.cve_data_all[cve]['collected_repo'] = list(repos)
        save_json(f'{self.project_root_path}/cve_data_all.json', self.cve_data_all)
        save_pickle(f'{self.project_root_path}/cve_data_all.pkl', self.cve_data_all)
        
        # self.check_result(res, 'repo_collection_incorrect')